#!/usr/bin/env python3
"""
Camera Calibration Utility for Scandium.

Performs camera intrinsic calibration using checkerboard pattern images.
Outputs calibration parameters in YAML format compatible with OpenCV.

Usage:
    python scripts/calibrate_camera.py --input ./calibration_images/ --output ./configs/camera/calib.yaml
"""

import argparse
from pathlib import Path
from typing import List, Tuple, Optional
import sys

import cv2
import numpy as np
from numpy.typing import NDArray


def find_checkerboard_corners(
    image_paths: List[Path],
    pattern_size: Tuple[int, int],
    square_size_mm: float,
) -> Tuple[List[NDArray], List[NDArray], Tuple[int, int]]:
    """
    Find checkerboard corners in calibration images.

    Args:
        image_paths: List of calibration image file paths.
        pattern_size: Inner corner count (columns, rows).
        square_size_mm: Physical square size in millimeters.

    Returns:
        Tuple of (object_points, image_points, image_size).
    """
    # Prepare object points (3D points in real world space)
    objp = np.zeros((pattern_size[0] * pattern_size[1], 3), np.float32)
    objp[:, :2] = np.mgrid[0 : pattern_size[0], 0 : pattern_size[1]].T.reshape(-1, 2)
    objp *= square_size_mm

    object_points: List[NDArray] = []
    image_points: List[NDArray] = []
    image_size: Optional[Tuple[int, int]] = None

    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

    print(f"Processing {len(image_paths)} calibration images...")

    for idx, image_path in enumerate(image_paths):
        img = cv2.imread(str(image_path))
        if img is None:
            print(f"  [{idx + 1}] {image_path.name}: Failed to load")
            continue

        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        if image_size is None:
            image_size = (gray.shape[1], gray.shape[0])

        # Find checkerboard corners
        found, corners = cv2.findChessboardCorners(
            gray,
            pattern_size,
            cv2.CALIB_CB_ADAPTIVE_THRESH
            + cv2.CALIB_CB_FAST_CHECK
            + cv2.CALIB_CB_NORMALIZE_IMAGE,
        )

        if found:
            # Refine corner positions
            corners_refined = cv2.cornerSubPix(
                gray, corners, (11, 11), (-1, -1), criteria
            )
            object_points.append(objp)
            image_points.append(corners_refined)
            print(f"  [{idx + 1}] {image_path.name}: Found {len(corners)} corners")
        else:
            print(f"  [{idx + 1}] {image_path.name}: Pattern not found")

    if image_size is None:
        raise ValueError("No valid images found")

    return object_points, image_points, image_size


def calibrate_camera(
    object_points: List[NDArray],
    image_points: List[NDArray],
    image_size: Tuple[int, int],
) -> Tuple[NDArray, NDArray, float]:
    """
    Perform camera calibration.

    Args:
        object_points: 3D object points.
        image_points: 2D image points.
        image_size: Image dimensions (width, height).

    Returns:
        Tuple of (camera_matrix, dist_coeffs, rms_error).
    """
    print(f"\nCalibrating with {len(object_points)} valid images...")

    rms_error, camera_matrix, dist_coeffs, rvecs, tvecs = cv2.calibrateCamera(
        object_points,
        image_points,
        image_size,
        None,
        None,
    )

    print(f"Calibration complete. RMS reprojection error: {rms_error:.4f} pixels")

    return camera_matrix, dist_coeffs, rms_error


def save_calibration(
    output_path: Path,
    camera_matrix: NDArray,
    dist_coeffs: NDArray,
    image_width: int,
    image_height: int,
    rms_error: float,
) -> None:
    """
    Save calibration results to YAML file.

    Args:
        output_path: Output file path.
        camera_matrix: 3x3 camera intrinsic matrix.
        dist_coeffs: Distortion coefficients.
        image_width: Image width in pixels.
        image_height: Image height in pixels.
        rms_error: RMS reprojection error.
    """
    # Ensure output directory exists
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Format for YAML output
    content = f"""# Camera Intrinsic Calibration
# Generated by Scandium calibration utility
# RMS reprojection error: {rms_error:.6f} pixels

camera_matrix:
  - [{camera_matrix[0, 0]:.6f}, {camera_matrix[0, 1]:.6f}, {camera_matrix[0, 2]:.6f}]
  - [{camera_matrix[1, 0]:.6f}, {camera_matrix[1, 1]:.6f}, {camera_matrix[1, 2]:.6f}]
  - [{camera_matrix[2, 0]:.6f}, {camera_matrix[2, 1]:.6f}, {camera_matrix[2, 2]:.6f}]

dist_coeffs: [{", ".join(f"{c:.6f}" for c in dist_coeffs.flatten())}]

image_width: {image_width}
image_height: {image_height}
"""

    with open(output_path, "w") as f:
        f.write(content)

    print(f"\nCalibration saved to: {output_path}")


def main() -> int:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Camera calibration utility for Scandium precision landing system.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "--input",
        "-i",
        type=Path,
        required=True,
        help="Directory containing calibration images",
    )

    parser.add_argument(
        "--output",
        "-o",
        type=Path,
        default=Path("configs/camera/calibration.yaml"),
        help="Output calibration YAML file path",
    )

    parser.add_argument(
        "--pattern",
        type=str,
        default="9x6",
        help="Checkerboard pattern size (inner corners, e.g., '9x6')",
    )

    parser.add_argument(
        "--square-size",
        type=float,
        default=25.0,
        help="Checkerboard square size in millimeters",
    )

    parser.add_argument(
        "--extensions",
        type=str,
        default="jpg,jpeg,png,bmp",
        help="Comma-separated list of image file extensions",
    )

    args = parser.parse_args()

    # Validate input directory
    if not args.input.is_dir():
        print(f"Error: Input directory does not exist: {args.input}")
        return 1

    # Parse pattern size
    try:
        cols, rows = map(int, args.pattern.lower().split("x"))
        pattern_size = (cols, rows)
    except ValueError:
        print(
            f"Error: Invalid pattern format '{args.pattern}'. Use format 'NxM' (e.g., '9x6')"
        )
        return 1

    # Find calibration images
    extensions = [ext.strip().lower() for ext in args.extensions.split(",")]
    image_paths = []
    for ext in extensions:
        image_paths.extend(args.input.glob(f"*.{ext}"))
        image_paths.extend(args.input.glob(f"*.{ext.upper()}"))

    if not image_paths:
        print(f"Error: No calibration images found in {args.input}")
        return 1

    image_paths = sorted(set(image_paths))
    print(f"Found {len(image_paths)} calibration images")
    print(f"Pattern size: {pattern_size[0]}x{pattern_size[1]} inner corners")
    print(f"Square size: {args.square_size} mm")

    try:
        # Find corners
        object_points, image_points, image_size = find_checkerboard_corners(
            image_paths,
            pattern_size,
            args.square_size,
        )

        if len(object_points) < 3:
            print(
                f"Error: Insufficient valid images (found {len(object_points)}, need at least 3)"
            )
            return 1

        # Calibrate
        camera_matrix, dist_coeffs, rms_error = calibrate_camera(
            object_points,
            image_points,
            image_size,
        )

        # Save results
        save_calibration(
            args.output,
            camera_matrix,
            dist_coeffs,
            image_size[0],
            image_size[1],
            rms_error,
        )

        # Print summary
        print("\n" + "=" * 60)
        print("CALIBRATION SUMMARY")
        print("=" * 60)
        print(f"Images processed: {len(image_paths)}")
        print(f"Images used: {len(object_points)}")
        print(f"Image resolution: {image_size[0]}x{image_size[1]}")
        print(f"RMS error: {rms_error:.4f} px")
        print(
            f"\nFocal length (fx, fy): ({camera_matrix[0, 0]:.2f}, {camera_matrix[1, 1]:.2f})"
        )
        print(
            f"Principal point (cx, cy): ({camera_matrix[0, 2]:.2f}, {camera_matrix[1, 2]:.2f})"
        )
        print(f"Distortion coefficients: {dist_coeffs.flatten()[:5]}")
        print("=" * 60)

        return 0

    except Exception as e:
        print(f"Error during calibration: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
